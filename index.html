<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GrokBOT - Semantic Memory</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <style>
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
        .dark ::-webkit-scrollbar-thumb { background: #475569; }
        .prose pre { background: #1e293b; color: #e2e8f0; padding: 1rem; border-radius: 0.5rem; overflow-x: auto; position: relative; }
        .typing-cursor::after { content: 'â–‹'; animation: blink 1s step-start infinite; }
        @keyframes blink { 50% { opacity: 0; } }
        .msg-actions { opacity: 0; transition: opacity 0.2s; display: flex; gap: 8px; }
        .group:hover .msg-actions { opacity: 1; }
        @media (max-width: 768px) { .msg-actions { opacity: 1; } }
    </style>
</head>
<body class="bg-white dark:bg-slate-900 text-slate-800 dark:text-slate-200 font-sans transition-colors duration-200">

    <div id="app-loader" class="fixed inset-0 z-50 flex flex-col items-center justify-center bg-white dark:bg-slate-900">
        <div class="w-12 h-12 border-4 border-blue-500 border-t-transparent rounded-full animate-spin mb-4"></div>
        <p class="text-slate-500">Loading Neural Memory...</p>
    </div>

    <div id="app" class="flex h-[100dvh] w-full hidden opacity-0 transition-opacity duration-300">
        <aside id="sidebar" class="absolute md:relative z-40 w-72 h-full bg-slate-50 dark:bg-slate-800 transform -translate-x-full md:translate-x-0 transition-transform duration-300 flex flex-col border-r border-slate-200 dark:border-slate-700 shadow-xl md:shadow-none">
            <div class="p-4">
                <button onclick="createNewChat()" class="w-full bg-blue-100 dark:bg-slate-700 hover:bg-blue-200 dark:hover:bg-slate-600 py-2.5 rounded-lg flex items-center justify-center gap-2 font-medium transition-colors">
                    <i class="fa-solid fa-plus"></i> New Chat
                </button>
            </div>
            <div class="flex-1 overflow-y-auto px-2" id="chat-history-list"></div>
            <div class="p-4 border-t border-slate-200 dark:border-slate-700 space-y-2">
                <div class="text-xs text-center text-slate-400 mb-2" id="memory-stats">Memories: 0 | Vectors: 0</div>
                <button onclick="openSettings()" class="w-full py-2 flex items-center justify-center gap-2 hover:bg-slate-200 dark:hover:bg-slate-700 rounded-lg">
                    <i class="fa-solid fa-gear"></i> Settings
                </button>
            </div>
        </aside>
        <div id="sidebar-overlay" onclick="toggleSidebar()" class="fixed inset-0 bg-black/50 z-30 hidden md:hidden glass"></div>

        <main class="flex-1 flex flex-col relative w-full h-full bg-white dark:bg-slate-900">
            <header class="md:hidden flex items-center justify-between p-4 border-b border-slate-100 dark:border-slate-800">
                <button onclick="toggleSidebar()"><i class="fa-solid fa-bars text-xl"></i></button>
                <span class="font-bold">GrokBOT RAG</span>
                <div class="w-6"></div>
            </header>

            <div id="messages-container" class="flex-1 overflow-y-auto p-4 md:p-8 space-y-6 scroll-smooth pb-32"></div>

            <div class="absolute bottom-0 left-0 w-full p-4 bg-gradient-to-t from-white via-white to-transparent dark:from-slate-900 dark:via-slate-900 z-20">
                <div class="max-w-3xl mx-auto relative">
                    <div id="image-preview-container" class="hidden absolute -top-16 left-0 bg-slate-100 dark:bg-slate-800 p-2 rounded-lg shadow border border-slate-300 dark:border-slate-700">
                        <img id="image-preview" src="" class="h-12 w-auto rounded">
                        <button onclick="clearImage()" class="absolute -top-2 -right-2 bg-red-500 text-white rounded-full w-5 h-5 text-xs"><i class="fa-solid fa-times"></i></button>
                    </div>

                    <div class="flex items-end gap-2 bg-slate-100 dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-3xl p-2 pl-4 shadow-sm">
                        <button onclick="document.getElementById('image-upload').click()" class="p-2 text-slate-500 hover:text-blue-500"><i class="fa-solid fa-paperclip text-lg"></i></button>
                        <input type="file" id="image-upload" accept="image/*" class="hidden" onchange="handleImageUpload(event)">
                        
                        <textarea id="user-input" rows="1" class="w-full bg-transparent border-none focus:ring-0 resize-none py-3 max-h-32 text-slate-800 dark:text-slate-100 placeholder-slate-500" placeholder="Ask something..."></textarea>
                        
                        <button onclick="sendMessage()" id="send-btn" class="p-2.5 bg-blue-600 hover:bg-blue-700 text-white rounded-full"><i class="fa-solid fa-paper-plane"></i></button>
                    </div>
                    <p id="status-indicator" class="text-center text-xs text-slate-400 mt-2">Ready.</p>
                </div>
            </div>
        </main>
    </div>

    <div id="settings-modal" class="fixed inset-0 z-50 flex items-center justify-center bg-black/60 hidden backdrop-blur-sm">
        <div class="bg-white dark:bg-slate-800 w-full max-w-md rounded-2xl shadow-2xl p-6 m-4 max-h-[90vh] overflow-y-auto">
            <h2 class="text-xl font-bold mb-4">Settings</h2>
            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-medium mb-1">API Key</label>
                    <input type="password" id="api-key-input" class="w-full bg-slate-100 dark:bg-slate-700 rounded px-3 py-2 border border-slate-300 dark:border-slate-600 focus:outline-none focus:border-blue-500">
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">System Prompt</label>
                    <textarea id="system-prompt" rows="4" class="w-full bg-slate-100 dark:bg-slate-700 rounded px-3 py-2 border border-slate-300 dark:border-slate-600 text-xs font-mono"></textarea>
                </div>
                <div class="flex justify-between items-center pt-2">
                    <button onclick="summarizeAllChats()" class="text-xs text-blue-500 hover:underline">Force Summarize All Chats</button>
                    <button onclick="clearAllData()" class="text-xs text-red-500 hover:underline">Reset All Data</button>
                </div>
            </div>
            <div class="mt-6 flex justify-end">
                <button onclick="saveSettings()" class="bg-blue-600 text-white px-6 py-2 rounded-lg">Save</button>
            </div>
        </div>
    </div>

    <script>
        // --- CONFIG ---
        const STATE_KEY = "GrokBOT_RAG_v1";
        const MODEL_NAME = "gemini-1.5-flash";
        const EMBEDDING_MODEL = "text-embedding-004"; 
        
        // --- DEFAULT PROMPT ---
        const DEFAULT_PROMPT = `You are GrokBOT, a highly intelligent AI assistant. 
        Style: Witty, smart, and concise. 
        Context Use: Use the provided [Relevant Memories] to answer if applicable. If memories contradict, prioritize recent ones.`;

        // --- STATE ---
        let state = {
            apiKey: "",
            systemPrompt: DEFAULT_PROMPT,
            theme: "dark", // defaulting to dark for "hacker" feel
            chats: [], // {id, title, messages: []}
            memories: [], // {chatId, summary, embedding: [], timestamp}
            currentChatId: null
        };

        let imagePayload = null;
        let isProcessing = false;

        // --- INIT ---
        document.addEventListener('DOMContentLoaded', () => {
            loadState();
            initTheme();
            
            // UI Listeners
            const ta = document.getElementById('user-input');
            ta.addEventListener('input', function() { this.style.height='auto'; this.style.height=this.scrollHeight+'px'; });
            ta.addEventListener('keydown', e => { if(e.key==='Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(); }});
            
            setTimeout(() => {
                document.getElementById('app-loader').classList.add('hidden');
                document.getElementById('app').classList.remove('hidden', 'opacity-0');
            }, 500);
        });

        // --- CORE LOGIC: RAG SYSTEM ---

        // 1. Generate Summary of a Chat
        async function generateSummary(chatId, messages) {
            if(messages.length < 4) return null; // Don't summarize very short chats
            
            const textToSummarize = messages.map(m => `${m.role}: ${m.text}`).join("\n");
            const prompt = `Summarize this conversation in 3-4 sentences. Focus on facts, user preferences, or technical details learned. Ignore small talk. \n\nChat:\n${textToSummarize}`;

            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${MODEL_NAME}:generateContent?key=${state.apiKey}`, {
                    method: 'POST', headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                });
                const data = await response.json();
                return data.candidates[0].content.parts[0].text;
            } catch(e) { console.error("Summary Failed:", e); return null; }
        }

        // 2. Generate Embedding (Vector)
        async function getEmbedding(text) {
            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${EMBEDDING_MODEL}:embedContent?key=${state.apiKey}`, {
                    method: 'POST', headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        model: `models/${EMBEDDING_MODEL}`,
                        content: { parts: [{ text: text }] }
                    })
                });
                const data = await response.json();
                return data.embedding.values; // Array of floats
            } catch(e) { console.error("Embedding Failed:", e); return null; }
        }

        // 3. Cosine Similarity (Math to find relevance)
        function cosineSimilarity(vecA, vecB) {
            let dotProduct = 0, magnitudeA = 0, magnitudeB = 0;
            for (let i = 0; i < vecA.length; i++) {
                dotProduct += vecA[i] * vecB[i];
                magnitudeA += vecA[i] * vecA[i];
                magnitudeB += vecB[i] * vecB[i];
            }
            return dotProduct / (Math.sqrt(magnitudeA) * Math.sqrt(magnitudeB));
        }

        // 4. Retrieve Relevant Memories
        async function getContext(queryText) {
            updateStatus("Accessing Neural Memory...");
            
            // Step A: Layer 1 - Recent Summaries (Last 5 days/chats)
            const recentMemories = state.memories
                .sort((a, b) => b.timestamp - a.timestamp)
                .slice(0, 5)
                .map(m => `- Recent Summary (${new Date(m.timestamp).toLocaleDateString()}): ${m.summary}`);

            // Step B: Layer 2 - Vector Search (Long Term)
            if (!state.apiKey) return recentMemories.join("\n");

            const queryVector = await getEmbedding(queryText);
            if (!queryVector) return recentMemories.join("\n");

            // Calculate similarity for ALL memories
            const scoredMemories = state.memories.map(mem => ({
                ...mem,
                score: mem.embedding ? cosineSimilarity(queryVector, mem.embedding) : 0
            }));

            // Filter top relevant (Score > 0.6 is usually good relevance)
            const vectorMemories = scoredMemories
                .filter(m => m.score > 0.6) 
                .sort((a, b) => b.score - a.score)
                .slice(0, 3) // Take top 3 relevant chunks
                .map(m => `- Relevant Past Memory (Score ${m.score.toFixed(2)}): ${m.summary}`);

            updateStatus("Ready.");
            
            // Combine unique memories
            const allContext = [...new Set([...recentMemories, ...vectorMemories])];
            return allContext.join("\n");
        }

        // --- CHAT LOGIC ---

        async function sendMessage() {
            const input = document.getElementById('user-input');
            const text = input.value.trim();
            if ((!text && !imagePayload) || !state.apiKey) { if(!state.apiKey) openSettings(); return; }
            if (isProcessing) return;

            if (!state.currentChatId) createNewChat();
            
            // UI Update
            input.value = ''; input.style.height = 'auto';
            isProcessing = true;
            document.getElementById('send-btn').disabled = true;

            const currentChat = state.chats.find(c => c.id === state.currentChatId);
            const userMsg = { role: 'user', text: text, image: imagePayload ? imagePayload.data : null };
            currentChat.messages.push(userMsg);
            saveState(); renderChat(); scrollToBottom();

            // AI Processing
            const aiPlaceholder = addPlaceholder();
            
            try {
                // 1. Build Context
                const memoryContext = await getContext(text);
                const systemInstruction = `${state.systemPrompt}\n\n[RELEVANT MEMORIES FROM DATABASE]:\n${memoryContext || "None found."}`;

                // 2. Prepare Payload
                const history = currentChat.messages.slice(-10).map(m => ({
                    role: m.role === 'user' ? 'user' : 'model',
                    parts: [{ text: m.text }]
                })); // Only last 10 messages of CURRENT chat for short-term flow

                // Add current message
                const currentParts = [{ text: text }];
                if (imagePayload) currentParts.push({ inline_data: { mime_type: imagePayload.mime_type, data: imagePayload.data } });

                // 3. Call API
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${MODEL_NAME}:streamGenerateContent?key=${state.apiKey}`, {
                    method: 'POST', headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        contents: [...history, { role: 'user', parts: currentParts }],
                        system_instruction: { parts: [{ text: systemInstruction }] },
                        generationConfig: { maxOutputTokens: 2000 }
                    })
                });

                // 4. Stream Response
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let fullText = "";
                
                while(true) {
                    const { done, value } = await reader.read();
                    if(done) break;
                    const chunk = decoder.decode(value, {stream: true});
                    // Simple parse for stream
                    const matches = chunk.match(/"text":\s*"((?:[^"\\]|\\.)*)"/g);
                    if(matches) {
                        matches.forEach(m => {
                            try { fullText += JSON.parse(`{${m}}`).text; } catch(e){}
                        });
                        aiPlaceholder.innerHTML = marked.parse(fullText);
                        scrollToBottom();
                    }
                }

                currentChat.messages.push({ role: 'model', text: fullText });
                saveState();
                
                // 5. AUTO-SUMMARIZE TRIGGER (Every 5 messages or end of thought)
                if(currentChat.messages.length % 6 === 0) {
                    updateStatus("Consolidating memory...");
                    const summary = await generateSummary(state.currentChatId, currentChat.messages);
                    if(summary) {
                        const vec = await getEmbedding(summary);
                        // Save/Update Memory
                        const existingMemIndex = state.memories.findIndex(m => m.chatId === state.currentChatId);
                        const memObj = { chatId: state.currentChatId, summary: summary, embedding: vec, timestamp: Date.now() };
                        
                        if(existingMemIndex >= 0) state.memories[existingMemIndex] = memObj;
                        else state.memories.push(memObj);
                        
                        saveState();
                        updateStatus("Memory updated.");
                    }
                }

            } catch (error) {
                aiPlaceholder.innerHTML = `<span class="text-red-500">Error: ${error.message}</span>`;
            } finally {
                isProcessing = false;
                document.getElementById('send-btn').disabled = false;
                clearImage();
                renderSidebar(); // Update stats
            }
        }

        // --- HELPERS ---
        function loadState() {
            const s = localStorage.getItem(STATE_KEY);
            if(s) state = {...state, ...JSON.parse(s)};
            document.getElementById('api-key-input').value = state.apiKey;
            document.getElementById('system-prompt').value = state.systemPrompt;
            if(state.currentChatId) renderChat();
            renderSidebar();
        }
        function saveState() { localStorage.setItem(STATE_KEY, JSON.stringify(state)); renderSidebar(); }
        function initTheme() { document.documentElement.classList.add('dark'); } // Force Dark
        
        function createNewChat() {
            const id = Date.now().toString();
            state.chats.unshift({id, title: "New Session", messages: []});
            state.currentChatId = id;
            saveState(); renderChat();
            if(window.innerWidth < 768) toggleSidebar();
        }

        function renderSidebar() {
            const list = document.getElementById('chat-history-list');
            list.innerHTML = state.chats.map(c => `
                <div onclick="state.currentChatId='${c.id}'; renderChat();" class="p-3 mb-1 rounded cursor-pointer ${c.id === state.currentChatId ? 'bg-blue-100 dark:bg-slate-700' : 'hover:bg-slate-200 dark:hover:bg-slate-800'}">
                    <div class="truncate text-sm">${c.title}</div>
                </div>`).join('');
            
            // Stats
            const vecCount = state.memories.filter(m => m.embedding).length;
            document.getElementById('memory-stats').innerText = `Memories: ${state.memories.length} | Vectors: ${vecCount}`;
        }

        function renderChat() {
            const chat = state.chats.find(c => c.id === state.currentChatId);
            const box = document.getElementById('messages-container');
            box.innerHTML = "";
            if(!chat) return;
            
            chat.messages.forEach((m, idx) => {
                const isUser = m.role === 'user';
                const div = document.createElement('div');
                div.className = `flex ${isUser ? 'justify-end' : 'justify-start'} group`;
                div.innerHTML = `
                    <div class="max-w-[85%] rounded-2xl p-4 ${isUser ? 'bg-blue-600 text-white' : 'bg-slate-200 dark:bg-slate-800'} relative">
                        ${m.image ? `<img src="data:${m.image.mime_type || 'image/jpeg'};base64,${m.image}" class="rounded mb-2 max-h-48">` : ''}
                        <div class="prose dark:prose-invert text-sm">${marked.parse(m.text)}</div>
                        
                        <div class="msg-actions absolute -bottom-6 ${isUser ? 'right-0' : 'left-0'} text-xs text-slate-500">
                            <button onclick="navigator.clipboard.writeText(\`${m.text.replace(/`/g, '\\`')}\`)"><i class="fa-regular fa-copy"></i></button>
                            ${isUser ? `<button onclick="deleteMsg(${idx})"><i class="fa-solid fa-trash text-red-400"></i></button>` : ''}
                        </div>
                    </div>
                `;
                box.appendChild(div);
            });
            setTimeout(scrollToBottom, 100);
        }

        function addPlaceholder() {
            const box = document.getElementById('messages-container');
            const div = document.createElement('div');
            div.className = "flex justify-start";
            div.innerHTML = `<div class="max-w-[85%] rounded-2xl p-4 bg-slate-200 dark:bg-slate-800"><div class="typing-cursor"></div></div>`;
            box.appendChild(div);
            return div.querySelector('div');
        }

        function deleteMsg(idx) {
            const chat = state.chats.find(c => c.id === state.currentChatId);
            chat.messages.splice(idx, 1);
            saveState(); renderChat();
        }

        function scrollToBottom() { const c = document.getElementById('messages-container'); c.scrollTop = c.scrollHeight; }
        function toggleSidebar() { document.getElementById('sidebar').classList.toggle('-translate-x-full'); document.getElementById('sidebar-overlay').classList.toggle('hidden'); }
        function openSettings() { document.getElementById('settings-modal').classList.remove('hidden'); }
        function closeSettings() { document.getElementById('settings-modal').classList.add('hidden'); }
        function saveSettings() { 
            state.apiKey = document.getElementById('api-key-input').value; 
            state.systemPrompt = document.getElementById('system-prompt').value; 
            saveState(); closeSettings(); 
        }
        function updateStatus(txt) { document.getElementById('status-indicator').innerText = txt; }
        function clearAllData() { if(confirm("Reset Everything?")) { localStorage.removeItem(STATE_KEY); location.reload(); }}
        
        function handleImageUpload(e) {
            const file = e.target.files[0];
            const reader = new FileReader();
            reader.onload = function(evt) {
                const b64 = evt.target.result;
                imagePayload = { mime_type: b64.split(';')[0].split(':')[1], data: b64.split(',')[1] };
                document.getElementById('image-preview').src = b64;
                document.getElementById('image-preview-container').classList.remove('hidden');
            };
            if(file) reader.readAsDataURL(file);
        }
        function clearImage() { imagePayload=null; document.getElementById('image-preview-container').classList.add('hidden'); }

        // Force Manual Summarization (Optional)
        async function summarizeAllChats() {
            updateStatus("Batch Summarizing...");
            for(let chat of state.chats) {
                const summary = await generateSummary(chat.id, chat.messages);
                if(summary) {
                    const vec = await getEmbedding(summary);
                    state.memories.push({ chatId: chat.id, summary, embedding: vec, timestamp: Date.now() });
                }
            }
            saveState();
            updateStatus("Batch Done.");
        }
    </script>
</body>
</html>
